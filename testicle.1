.ss 12 0
.
.TH testicle 1 "MAR 2014" "Testicle" "User Manuals"
.
.
.SH "NAME"
testicle \- build C++ unit tests
.
.
.SH "SYNOPSIS"
.B testicle
.RB [ \-o
.IR outfile ]
.RB [ --tests = \fIpattern ]
\&...
.I infile
\&...
.br
.B testicle
.B --help
.br
.B testicle
.B --version
.
.
.SH "DESCRIPTION"
.B testicle
accepts one or more object files or archive libraries
containing test functions (referred to here as
.IR tests )
and generates C++ source for driving those tests.
.PP
It works by invoking
.BR nm (1)
to find symbols likely to be tests in those object files.
Compiling, linking and executing the tests
is left to the user,
through a Makefile or other means.
.PP
Tests are written in C++, but the target of the tests can be written in any
language, as long as it can be linked into a C++ program.
Specifically, this means that you can write tests for C source code.
.
.
.SS "Test functions"
.
Test functions must have one of the signatures
.IP
\fIvoid ...(testicle::TC);\fP
.br
\fIvoid test...();\fP
.PP
i.e. either be a function taking a single dummy
.I testicle::TC
argument,
or take no arguments but have a name starting with
.IR test .
.PP
Tests may be inside the global or any other named namespace.
Arranging tests into a nested hierarchy of namespaces
is the best way of grouping tests.
.PP
Executing a test results in one out of three things:
.IP \fB\s-2PASS\s0
The function returns normally.
.IP \fB\s-2FAIL\s0
The function throws a
.B testicle::Failure
exception. Utility functions for throwing these
are available in
.B testicle.h
(see
.I Assertions
below).
.IP \fB\s-2ERROR\s0
The function throws any other exception.
.PP
Of course, the test may also crash, run forever, or call
.BR std::exit ()
or some similar function.
These things are not caught.
.
.
.SS "Assertions"
A test function may raise
.B testicle::Failure
explicitly, with or without a string detailing the failure.
You may pass any other object, as long as it can be placed
on an ostream.
.IP
.if t .ft I
.nf
testicle::\fBFailure\fP(const std::string& \fImessage\fP);
testicle::\fBFailure\fP(const std::ostringstream& \fImessage\fP);
template<class T> testicle::\fBFailure\fP(const T& \fImessage\fP);
.fi
.PP
For convenience, 
.B testicle.h
provides a number of templated assertions:
.IP
.if t .ft I
.nf
#include <testicle.h>
using namespace testicle;

assert_(\fIval\fP);
assert_eq(\fIa\fP, \fIb\fP);	// a==b
assert_neq(\fIa\fP, \fIb\fP);	// a!=b
assert_lt(\fIa\fP, \fIb\fP);	// a<b
assert_gt(\fIa\fP, \fIb\fP);	// a>b
assert_le(\fIa\fP, \fIb\fP);	// a<=b
assert_ge(\fIa\fP, \fIb\fP);	// a>=b

assert_in(\fIfirst\fP, \fIlast\fP, \fIval\fP);  // std::find(first, last, val)!=last
assert_in(\fIcontainer\fP, \fIval\fP);
assert_not_in(\fIfirst\fP, \fIlast\fP, \fIval\fP);
assert_not_in(\fIcontainer\fP, \fIval\fP);
.fi
.PP
These work as long as the appropriate operators
.RB ( == ,
.BR != ,
.B <
and so on)
are defined for the types involved,
and they can be placed on a
.BR std::ostream .
Note that types may be mixed. For example, this test passes
because 3.14159\~>\~3:
.IP
assert_gt(3.14159, 3);
.PP
There is nothing magical about these utility assertions.
You may of course provide your own,
perhaps more suited to the problem domain.
If you do, please retain the convention:
.IP
When an assertion fails, the text that is printed
is the condition which
.I didn't
hold, for example
.IR "2\~<\~1".
.PP
Inverting the meaning to say
.IR "2\~>=\~1"
would be misleading in the general case; there is no guaranteed
correlation between
.I operator<\~()
and
.IR operator>=\~() .
.
.
.SS "The test program"
The executable test program generated by
.B testicle
has the synopsis
.PP
.B ./test
.RB [ \-vc ]
.RI [ pattern
\&...]
.br
.B ./test
.B \-l
.RI [ pattern
\&...]
.PP
If you don't provide any options, the program
executes all tests or all tests matching the given pattern(s),
and returns with a zero exit status if all of them pass.
.IP \fB\-v
By default, a brief progress indication,
a list of failures and errors,
and a summary
are printed to standard error.
This option also prints test names as they are executed.
.IP \fB\-c
Run the tests without catching exceptions,
so that a failure or error causes the program to crash and generate a core dump
(or whatever your environment provides for post mortem debugging).
.IP \fB\-l
List the tests without executing them.
.
.
.SS "The Makefile"
A Makefile
is a reasonable way of driving unit tests.
The interesting portions might look like this:
.IP
.if t .ft I
.nf
\&.PHONY: check checkv
check: tests
	./tests
checkv: tests
	valgrind -q ./tests -v

test.cc: libtest.a
	testicle -o$@ $^

tests: test.o libfoo.a libtest.a
	$(CXX) $(CXXFLAGS) -o $@ test.o -L. -ltest -lfoo
.fi
.
.
.SH "OPTIONS"
.
.
.IP \fB\-o\ \fIoutfile
Name the C++ source test driver.
If not provided, it will be named, simply,
.BR test.cc .
.
.
.IP \fB--tests=\fIpattern
Assume symbols matching the Perl-compatible regular expression
.I pattern
are tests, instead of any function, in any namespace,
whose name starts with
.BR test .
This option can be repeated to make it easier to say
\[lq]this pattern or that pattern\[rq].
.
.IP
Test functions which take a
.I testicle::TC
argument are always included.
.
.
.IP \fB--help
Print the usage message and exit.
.
.
.IP \fB--version
Print version information and exit.
.
.
.SH "EXIT STATUS"
.B 0
if the test program is generated correctly.
.
.
.SH "NOTES"
The primary aim of
.B testicle
is to make it easy for lazy users to add a test:
easy to understand how to do it,
with no header file to keep in sync,
and no need to somehow register each test
(with the risk of forgetting to do it, and believing the
test passes when in fact it never gets executed).
.PP
The primary weakness is, I suppose, in diagnostics.
You may get to see the values involved in a failing test,
but you don't get the file and line number.
This design was chosen under the assumptions that tests don't normally fail,
and that if they do, you want a debuggable core dump anyway \- the
.B \-c
option.
.IP
(I'm also assuming that stack unwinding caused by the exception doesn't
destroy the state you want to debug,
i.e. the state when the exception was thrown.
It seems to work well with gcc, and I suppose self-preservation makes most
compiler vendors enable post mortem inspection of unexpected exceptions.)
.PP
It might have been a mistake to include
.B \s-2ERROR\s0
as an outcome from a test. This was modeled on
.IR PyUnit ,
but the things this covers in Python
tend to map to quick and painless crashes
\- or compile-time errors \- in C++.
.PP
Some might find
.B testicle
an unfortunate name:
the unpalatable meeting of
\[lq]test\[rq] and
\[lq]popsicle\[rq].
Well,
.I \s-2CPPUNIT\s0
is a pretty unfortunate name, too ...
.PP
Finally:
yes, I am aware that there are lot of failed attempts at writing
C++ unit test frameworks.
I also realize that this one may have failed,
depending on your point of view.
.
.
.SH "AUTHOR"
J\(:orgen Grahn
.I \[fo]grahn+src@snipabacken.se\[fc]
.
.
.SH "LICENSE"
This software is released under the
.IR "Modified BSD License" .
.
.
.SH "SEE ALSO"
.BR nm (1).
