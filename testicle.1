.\" $Id$
.TH testicle 1 "JUL 2007" "Testicle" "User Manuals"
.
.
.SH "NAME"
testicle \- build C++ unit tests
.
.
.SH "SYNOPSIS"
.B testicle
.RB [ \-o
.IR outfile ]
.RB [ --tests = \fIpattern ]
.I infile
\&...
.br
.B testicle
.B --help
.br
.B testicle
.B --version
.
.
.SH "DESCRIPTION"
.B testicle
accepts one or more object files or archive libraries
containing test functions (referred to here as
.IR tests )
and generates C++ source for driving those tests.
.PP
It works by invoking
.B nm
to find symbols likely to be tests in those object files.
Compiling, linking and executing the tests
is left to the user,
through a Makefile or other means.
.
.
.SS "Test functions"
.
Test functions must have the signature
.IP
\fIvoid test...();\fP
.PP
and may be inside the global or any other namespace.
There is no requirement to group the tests into classes.
In fact, there is no direct support for doing so.
.PP
Executing a test results in one out of three things:
.IP \fB\s-2PASS\s0
the function returns normally
.IP \fB\s-2FAIL\s0
the function throws a
.B testicle::Failure
exception. Utility functions for throwing these
are available in
.BR testicle.h .
.IP \fB\s-2ERROR\s0
the function throws any other exception.
.PP
Of course, the test may also crash, run forever, or call
.BR std::exit ()
or some similar function.
.
.
.SS "Assertions"
A test function may raise
.B testicle::Failure
explicitly, with or without a string detailing the failure.
.PP
For convenience, 
.B testicle.h
provides a number of templated assertions:
.IP
.nf
assert_(\fIval\fP)
assert_eq(\fIval1\fP, \fIval2\fP)
assert_neq(\fIval1\fP, \fIval2\fP)
assert_lt(\fIval1\fP, \fIval2\fP)
assert_gt(\fIval1\fP, \fIval2\fP)

assert_in(\fIfirst\fP, \fIlast\fP, \fIval\fP)
assert_in(\fIcontainer\fP, \fIval\fP)
assert_not_in(\fIfirst\fP, \fIlast\fP, \fIval\fP)
assert_not_in(\fIcontainer\fP, \fIval\fP)
.fi
.PP
These work as long as the appropriate operators
.RB ( == ,
.BR != ,
.B <
and so on)
are defined for the types involved,
and they can be placed on a
.BR std::ostream .
Note that types may be mixed. For example, this test passes:
.IP
assert_gt(3.14159, 3);
.PP
There is nothing magical about these utility assertions.
You may of course provide your own,
perhaps more suited to the problem domain.
If you do, please retain the following convention:
.IP
When an assertion fails, the text that is printed
is the condition which
.I didn't
hold, for example
.IR "2 < 1".
Inverting the meaning to say
.IR "2 >= 1"
would be misleading in the general case; there is no guaranteed
correlation between
.I operator<\~()
and
.IR operator>=\~() .
.
.
.SS "The test program"
The executable test program generated by
.B testicle
has the synopsis
.PP
.B ./test
.RB [ \-vc ]
.RI [ pattern
\&...]
.br
.B ./test
.B \-l
.RI [ pattern
\&...]
.PP
The second form simply lists tests without executing them.
.PP
The first form executes all tests or all tests matching the given pattern(s),
and returns with a zero exit status if all of them pass.
By default, a brief progress indication,
a list of failures
and a summary
are printed to standard error. The
.B \-v
option makes the progress more verbose.
.PP
The
.B \-c
option runs the tests without catching exceptions,
so that a failure or error causes the program to crash and generate a core dump
(or whatever your environment provides for post mortem debugging).
.
.
.SH "OPTIONS"
.
.
.IP \-o\ \fIoutfile
Name the C++ source test driver.
If not provided, it will be named, simply,
.BR test.cc .
.
.
.IP --tests=\fIpattern
Assume symbols matching the Perl-compatible regular expression
.I pattern
are tests, instead of any function, in any namespace,
whose name starts with
.BR test .
.
.
.IP --help
Print the usage message and exit.
.
.
.IP --version
Print version information and exit.
.
.
.SH "EXIT STATUS"
.B 0
if the test program is generated correctly.
.
.
.SH "NOTES/BUGS"
The primary aim of
.B testicle
is to make it easy for lazy users to add a test:
easy to understand how to do it,
with no header file to keep in sync,
and no need to somehow register each test
(with the risk of forgetting to do it, and believing the
test passes when in fact it never gets executed).
.PP
The primary weakness is, I suppose, in diagnostics.
Assertions are not macros,
so while you may get to see the values involved in a failing test,
you don't get the file and line number.
This was chosen under the assumptions that tests don't normally fail,
and that if they do, you want a debuggable core dump anyway (the
.B \-c
option).
.PP
It might have been a mistake to include
.B \s-2ERROR\s0
as an outcome from a test. It was modeled on
.IR PyUnit ,
but the things this covers in Python
tend to map to quick and painless crashes in C++.
.PP
Some might find
.B testicle
an unfortunate name.
I'm sorry, but it was too funny to ignore:
the unpalpable meeting of
\[lq]test\[rq] and
\[lq]popsicle\[rq].
And besides,
.I CPPUNIT
is a pretty unfortunate name, too ...
.PP
Finally:
yes, I am aware that there are lot of failed attempts at writing
C++ unit test frameworks.
I also realize that this one may have failed,
depending on your point of view.
.
.
.SH "AUTHOR"
J\(:orgen Grahn
.I \[fo]grahn+src@snipabacken.dyndns.org\[fc]
.PP
This software is released under the
.IR "Modified BSD License" .
.
.
.SH "SEE ALSO"
.BR nm (1).
