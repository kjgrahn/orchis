.ss 12 0
.hw name-space
.
.TH orchis 1 "DEC 2019" "Orchis" "User Manuals"
.
.
.SH "NAME"
orchis \- build C++ or C unit tests
.
.
.SH "SYNOPSIS"
.B orchis
.RB [ \-o
.IR outfile ]
.RB [ \-t
.IR template ]
.I infile
\&...
.br
.B orchis
.B --help
.br
.B orchis
.B --version
.
.
.SH "DESCRIPTION"
.B orchis
accepts one or more object files or archive libraries
containing test functions (referred to here as
.IR tests )
and generates C++ source for driving those tests.
.PP
It works by invoking
.BR nm (1)
to find symbols likely to be tests in those object files.
Compiling, linking and executing the tests
is left to the user,
through a Makefile or by other means.
.PP
Tests are normally written in C++,
but the target of the tests (the system under test)
can be written in any
language, as long as it can be linked into a C++ program.
Specifically, this means that you can write tests for C source code.
.PP
Tests written in C are also supported, although with reduced
functionality. This can be useful if you're uncomfortable with even
simple C++, or if the target is not easily callable from C++
(perhaps header files you need to include handle things such as
enums or void pointers in a way that's not C++ compatible).
.
.
.SS "Test functions"
.
Test functions must have one of the signatures
.IP
.if t .ft I
void foo(orchis::TC);
.br
void testfoo();
.br
void testfoo(void); // C function
.PP
i.e. either be a function taking a single dummy
.I orchis::TC
argument,
or take no arguments but have a name starting with
.IR test .
.PP
Tests may be inside the global or any other named namespace.
Arranging tests into a nested hierarchy of namespaces
is the best way of grouping tests.
.PP
A test function may call other functions \- helper functions or
functions which are the
.I actual
tests. Do whatever makes the tests as readable as possible.
It's not uncommon to end up with a set of specialized assertion
functions which make the test functions clearer.
.PP
Executing a test results in one out of three things:
.IP \fB\s-2PASS\s0
The function returns normally.
.IP \fB\s-2FAIL\s0
The function throws a
.B orchis::Failure
exception. Utility functions for throwing these
are available in
.B orchis.h
(see
.I Assertions
below).
.IP \fB\s-2ERROR\s0
The function throws any other exception.
.PP
Of course, the test may also crash, run forever, or call
.BR std::exit ()
or some similar function.
These things are not caught.
.
.
.SS "Assertions"
A test function may raise
.B orchis::Failure
explicitly, with or without a string detailing the failure.
You may pass any other object, as long as it can be placed
on an ostream.
.IP
.if t .ft I
.nf
orchis::\fBFailure\fP(const std::string& \fImessage\fP);
orchis::\fBFailure\fP(const std::ostringstream& \fImessage\fP);
template<class T> orchis::\fBFailure\fP(const T& \fImessage\fP);
.fi
.PP
For convenience, 
.B orchis.h
provides a number of templated assertions:
.IP
.if t .ft I
.nf
#include <orchis.h>
using namespace orchis;

assert_true(\fIval\fP);	// synonym assert_(\fIval\fP)
assert_false(\fIval\fP);
assert_eq(\fIa\fP, \fIb\fP);	// a==b
assert_neq(\fIa\fP, \fIb\fP);	// a!=b
assert_lt(\fIa\fP, \fIb\fP);	// a<b
assert_gt(\fIa\fP, \fIb\fP);	// a>b
assert_le(\fIa\fP, \fIb\fP);	// a<=b
assert_ge(\fIa\fP, \fIb\fP);	// a>=b

assert_in(\fIfirst\fP, \fIlast\fP, \fIval\fP);  // std::find(first, last, val)!=last
assert_in(\fIcontainer\fP, \fIval\fP);
assert_not_in(\fIfirst\fP, \fIlast\fP, \fIval\fP);
assert_not_in(\fIcontainer\fP, \fIval\fP);
.fi
.PP
These work as long as the appropriate operators
.RB ( == ,
.BR != ,
.B <
and so on)
are defined for the types involved,
and they can be placed on a
.BR std::ostream .
Note that types may be mixed. For example, this test passes
because 3.14159\~>\~3:
.IP
assert_gt(3.14159, 3);
.PP
There is nothing magical about these utility assertions.
You may of course provide your own,
perhaps more suited to the problem domain.
If you do, please retain the convention:
.IP
When an assertion fails, the text that is printed
is the condition which
.I didn't
hold, for example
.IR "2\~<\~1".
.PP
Inverting the meaning to say
.IR "2\~>=\~1"
would be misleading in the general case; there is no guaranteed
correlation between
.I operator<\~()
and
.IR operator>=\~() .
Also remember the meaning of the word
.IR assert :
to boldly claim that something is true.
.
.
.SS "Assertions in C tests"
If your tests are written in C, the
.B orchis::Failure
exception is of course not available, and neither are the
.BR orchis::assert_\fIfoo ()
utilities.
Instead you use a traditional assertion macro:
.IP
.if t .ft I
.nf
ASSERT(condition);
.fi
.
.
.SS "The test program"
The executable test program generated by
.B orchis
has the synopsis
.PP
.B ./test
.RB [ \-vc ]
.RI [ pattern
\&...]
.br
.B ./test
.B \-l
.RI [ pattern
\&...]
.PP
If you don't provide any options, the program
executes all tests or all tests matching the given pattern(s),
and returns with a zero exit status if all of them pass.
.IP \fB\-v
By default, a brief progress indication,
a list of failures and errors,
and a summary
are printed to standard error.
This option also prints test names as they are executed.
.IP \fB\-c
Run the tests without catching exceptions,
so that a failure or error causes the program to crash and generate a core dump.
.IP \fB\-l
List the tests without executing them.
.
.
.SS "The Makefile"
A Makefile
is a good way of driving unit tests.
The interesting portions might look like this:
.IP
.if t .ft I
.nf
\&.PHONY: check checkv
check: tests
	./tests
checkv: tests
	valgrind -q ./tests -v

test.cc: libtest.a
	orchis -o$@ $^

tests: test.o libfoo.a libtest.a
	$(CXX) $(CXXFLAGS) -o $@ $< -L. -ltest -lfoo
.fi
.PP
Then it's just a matter of populating
.I libtest.a
with tests which exercise features provided by
.IR libfoo.a .
.
.
.SH "OPTIONS"
.
.
.IP \fB\-o\ \fIoutfile
Name the C++ source test driver.
If not provided, it will be named, simply,
.BR test.cc .
.
.
.IP \fB\-t\ \fItemplate
The template for the C++ source test driver to be generated;
by default
.IR lib/driver.template .
You can safely ignore this option.
.
.
.IP \fB--help
Print the usage message and exit.
.
.
.IP \fB--version
Print version information and exit.
.
.
.SH "EXIT STATUS"
.B 0
if the test program is generated correctly.
.
.
.SH "NOTES"
Test functions cannot be template instantiations.
You cannot write e.g.
.IR "test_something<T>(orchis::TC)" ,
instantiate it explicitly for
.I std::string
and
.IR std::vector<char> ,
and have these work as tests.
.PP
This was originally a simple oversight, but it won't be fixed
since the resulting test names would be too long and unwieldy to be useful.
You're welcome to write templated tests, but you have to instantiate
them in wrapper test cases.
.PP
The primary aim of
.B orchis
is to make it easy for lazy users to add a test:
easy to understand how to do it,
with no header file to keep in sync,
and no need to somehow register each test.
.PP
The primary weakness is, I suppose, in diagnostics.
You may get to see the values involved in a failing test,
but you don't get the file and line number.
This design was chosen under the assumptions that tests don't normally fail,
and that if they do, you want a debuggable core dump anyway \- the
.B \-c
option.
.IP
(I'm also assuming that stack unwinding caused by the exception doesn't
destroy the state you want to debug,
i.e. the state when the exception was thrown.
It seems to work well with gcc, and I suppose self-preservation makes most
compiler vendors enable post mortem inspection of unexpected exceptions.)
.PP
The assertion mechanism also favors code where types are printable, i.e. there
is an
.IR "ostream << T" .
It's a convention that's natural to me, but perhaps not to others, especially not
to people whose programs don't deal with text.
.PP
It might have been a mistake to include
.B \s-2ERROR\s0
as an outcome from a test. This was modeled on
.IR PyUnit ,
but the things this covers in Python
tend to map to quick and painless crashes
\- or compile-time errors \- in C++.
.PP
If your build tool has problems dealing with generated source code,
tough luck.
GNU
.BR make (1)
has no such limitations, and that's the only tool I use.
Perhaps there's an extension mechanism for other tools.
.SS "C tests"
The limited support for tests written in C was created after an
attempt I did to test a C code base.  Header files may (especially if they
contain a lot of inline functions) need modification to be callable from C++,
and that may not be desireable if there is no need for C++ compatibility
outside the unit tests.
.PP
Note though that writing tests in C++ is preferable:
tests can be expressed much more clearly in a higher-level language.
In particular, I find it very helpful to use namespaces to group tests,
and to have access to standard containers.
RAII is also useful; it's the only simple way to clean up after a
test fails.
.PP
Perhaps the C test functionality should have been broken out into a
separate utility, but the test driver part and the test case discovery
part are the same.
Also, there are certain benefits of having all your tests (C or C++)
available in one binary.
.
.SS "Name and compatibility"
.B Orchis
used to be called
.B testicle
for many years, until a friend convinced me other friends might
be uncomfortable with the name.
.I Orchis
is a Greek word meaning the same thing
(and also the name of a genus in
.IR Orchidaceae ,
the orchids).
.PP
Tests written for
.B testicle
still work; the difference is in the namespace name and the
header file
.RI ( orchis.h
versus
.IR testicle.h ).
.
.
.SH "AUTHOR"
J\(:orgen Grahn
.I \[fo]grahn+src@snipabacken.se\[fc]
.
.
.SH "LICENSE"
This software is released under the
.IR "Modified BSD License" .
.
.
.SH "SEE ALSO"
.BR nm (1),
.BR make (1).
