#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
#
# $Id$
#
# Copyright (c) 2007 Jörgen Grahn.
# All rights reserved.
#
"""build C++ unit tests
"""
import os
import re


def make(infiles):
    """Make the files 'infiles' by invoking make(1), returning success.
    Unused; it was a bad idea.
    """
    f = os.popen('make %s' % ' '.join(['"%s"' % s for s in infiles]))
    sys.stdout.write(f.read())
    return not f.close()


def find_tests(infiles, testres):
    """Find and return all symbols
    matching any of the REs 'testres'
    in object files 'infiles'.
    """
    funre = re.compile(r'^([\w:]+)\((?:void)?\)\sT\s')
    f = os.popen('nm -CP %s' % ' '.join(['"%s"' % s for s in infiles]))
    tests = []
    for s in f.xreadlines():
        m = funre.match(s)
        if not m:
            continue
        fn = m.group(1)
        for rex in testres:
            if rex.match(fn):
                tests.append(fn)
                break
    rc = f.close()
    return tests

def prototypes(testnames, f):
    """Write function declarations to 'f',
    handling namespaces correctly.
    """
    w = f.write
    for name in testnames:
        n = name.split('::')
        nss, f = n[:-1], n[-1]
        indent = 0
        for ns in nss:
            w(' ' * indent)
            w('namespace %s {\n' % ns)
            indent += 2
        w(' ' * indent)
        w('void %s();\n' % f)
        w('}' * len(nss))
        w('\n')

def source(testnames, f):
    """Generate main test program source to file-like object 'w',
    for the test functions listed in sequence 'testnames'.
    """
    w = f.write
    w(r"""#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>
#include <string>
#include <unistd.h>

#include <testicle.h>

""")

    prototypes(testnames, f)

    w(r"""namespace {

    class Progress {
    public:
        Progress(std::ostream& os, bool verbose, int indent)
	    : os_(os),
	      verbose_(verbose),
              indent_(indent),
	      pass_(0),
	      fail_(0),
	      error_(0)
	{}

	void begin(const char * name);
	void pass();
	void fail(const testicle::AssertionError& error);
	void error();
	void done();
	int rc() const { return fail_+error_!=0; }

    private:
	struct Problem {
	    Problem(const std::string& nam,
		    const testicle::AssertionError& err)
		: name(nam),
		  error(err)
	    {}
	    std::string name;
	    testicle::AssertionError error;
	};

	std::ostream& os_;
	const bool verbose_;
        const int indent_;
	int pass_;
	int fail_;
	int error_;
	std::string current_;
	std::vector<Problem> problems_;
    };

    void Progress::begin(const char * name)
    {
	current_ = name;
	if(verbose_) {
           os_ << name
               << std::string(indent_ - std::strlen(name), ' ')
               << std::flush;
	}
    }

    void Progress::pass()
    {
	pass_++;
	if(verbose_) {
	    os_ << "ok" << std::endl;
	}
	else {
	    os_ << '.' << std::flush;
	}
    }

    void Progress::fail(const testicle::AssertionError& error)
    {
	fail_++;
	if(verbose_) {
	    os_ << "FAIL" << std::endl;
	}
	else {
	    os_ << 'F' << std::flush;
	}

	problems_.push_back(Problem(current_, error));
    }

    void Progress::error()
    {
	error_++;
	if(verbose_) {
	    os_ << "ERROR" << std::endl;
	}
	else {
	    os_ << 'E' << std::flush;
	}
    }

    void Progress::done()
    {
	static const char hr[] = "----------------------------------------"
	                         "------------------------------\n";

	if(!verbose_) {
	    os_ << '\n';
	}
	os_ << hr;

	for(std::vector<Problem>::const_iterator i = problems_.begin();
	    i != problems_.end();
	    ++i) {
	    os_ << i->name << '\n'
		<< i->error << '\n'
		<< hr;
	}

	if(fail_+error_ == 0) {
	    os_ << "OK (" << pass_ << " tests)\n";
	}
	else {
	    int total = pass_ + fail_ + error_;
	    os_ << "FAILED (" << total << " tests; "
		<< fail_ << " FAIL, "
		<< error_ <<" ERROR)\n";
	}
    }

    struct Entry {
	char * name;
	void (*f)();
    };


    class NonMatch {
    public:
	NonMatch(char ** begin, char ** end)
	    : begin_(begin),
	      end_(end)
	{}

	bool operator() (const Entry& e) const;

    private:
	char ** const begin_;
	char ** const end_;
    };

    bool NonMatch::operator() (const Entry& e) const
    {
	char ** i = begin_;
	while(i!=end_) {
	    if(std::strstr(e.name, *i)==e.name) return false;
	    ++i;
	}
	return true;
    }
}


int main(int argc, char ** argv)
{
    const char * const prog = argv[0];

    static const Entry entries[] = {
""")

    for name in testnames:
        w('\t{"%s", %s},\n' % (name, name))

    w(r"""    };

    static const size_t NENTRIES = sizeof(entries)/sizeof(entries[0]);

    bool verbose = false;
    size_t indentation = 0;
    bool just_list = false;
    bool bork_on_fail = false;

    int ch;
    while((ch = getopt(argc, argv, "+vlc")) != -1) {
	switch(ch) {
	case 'v':
	    verbose = true;
            for(size_t i=0; i<NENTRIES; ++i) {
                indentation = std::max(indentation,
                                       std::strlen(entries[i].name) + 1);
            }
	    break;
	case 'l':
	    just_list = true;
	    break;
	case 'c':
	    bork_on_fail = true;
	    break;
	case '?':
	default:
	    std::cerr << "usage: " << prog << " [-vc] [pattern ...]\n"
		      << "       " << prog << " -l [pattern ...]\n";
	    return 0;
	}
    }

    std::vector<Entry> chosen(entries, entries+NENTRIES);
    if(optind!=argc) {
	chosen.erase(std::remove_if(chosen.begin(), chosen.end(),
				    NonMatch(argv+optind, argv+argc)),
		     chosen.end());
    }

    if(just_list) {
	for(std::vector<Entry>::const_iterator i = chosen.begin();
	    i!=chosen.end();
	    ++i) {
	    std::cout << i->name << '\n';
	}
	return 0;
    }

    Progress p(std::cout, verbose, indentation);

    for(std::vector<Entry>::const_iterator i = chosen.begin();
	i!=chosen.end();
	++i) {

	const Entry& e = *i;

	p.begin(e.name);

	if(bork_on_fail) {
	    e.f();
	    p.pass();
	}
	else {
	    try {
		e.f();
		p.pass();
	    }
	    catch(testicle::AssertionError& err) {
		p.fail(err);
	    }
	    catch(...) {
		p.error();
	    }
	}
    }
    p.done();

    return p.rc();
}
""")


if __name__ == "__main__":
    import sys
    import getopt

    prog = os.path.split(sys.argv[0])[1]
    usage = ('usage: %(prog)s [-o outfile] [--tests=pattern] infile ...\n'
             '       %(prog)s --help\n'
             '       %(prog)s --version') % locals()
    outfile = 'test.cc'
    testres = []

    try:
        opts, infiles = getopt.getopt(sys.argv[1:], 'o:',
                                    ['tests=', 'version', 'help'])
        for opt, value in opts:
            if opt=='-o':
                outfile = value
            elif opt=='--tests':
                testres.append(re.compile(value))
            elif opt=='--version':
                print prog
                print "$Id$"
                print "Copyright (c) 2007 Jörgen Grahn."
                print "All rights reserved."
                sys.exit(0)
            elif opt=='--help':
                print usage
                sys.exit(0)
        if not infiles:
            raise ValueError('no input file specified')
    except (getopt.GetoptError, ValueError, re.error), s:
        print >>sys.stderr, s
        print >>sys.stderr, usage
        sys.exit(1)

    if not testres:
        testres.append(re.compile(r'^(.+::)?test\w*$'))

    tests = find_tests(infiles, testres)

    of = open(outfile, 'w')
    source(tests, of)
    of.close()

    sys.exit(0)
