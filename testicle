#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
#
# $Id$
#
# Copyright (c) 2007 Jörgen Grahn.
# All rights reserved.
#
"""build C++ unit tests
"""
import os
import re


def make(infiles):
    """Make the files 'infiles' by invoking make(1), returning success.
    """
    f = os.popen('make %s' % ' '.join(['"%s"' % s for s in infiles]))
    sys.stdout.write(f.read())
    return not f.close()


def find_tests(infiles, testres):
    """Find and return all symbols
    matching any of the REs 'testres'
    in object files 'infiles'.
    """
    funre = re.compile(r'^(\w+)\(void\)\sT\s')
    f = os.popen('nm -CP %s' % ' '.join(['"%s"' % s for s in infiles]))
    tests = []
    for s in f.xreadlines():
        m = funre.match(s)
        if m: tests.append(m.group(1))
    rc = f.close()
    return tests

def source(testnames, f):
    """Generate main test program source to file-like object 'w',
    for the test functions listed in sequence 'testnames'.
    """
    w = f.write
    w(r"""#include <iostream>
#include <algorithm>
#include <vector>
#include <cstring>
#include <unistd.h>

#include <testicle.h>

""")

    for name in testnames:
        w('void %s();\n' % name)

    w(r"""
namespace {

    class Progress {
    public:
	Progress(std::ostream& os, bool verbose)
	    : os_(os),
	      verbose_(verbose),
	      pass_(0),
	      fail_(0),
	      error_(0)
	{}

	void begin(const char * name);
	void pass();
	void fail();
	void error();
	void done();
	int rc() const { return !(fail_+error_); }

    private:
	std::ostream& os_;
	const bool verbose_;
	int pass_;
	int fail_;
	int error_;
    };

    void Progress::begin(const char * name)
    {
	if(verbose_) {
	    os_ << name << " ... " << std::flush;
	}
    }

    void Progress::pass()
    {
	pass_++;
	if(verbose_) {
	    os_ << "ok" << std::endl;
	}
	else {
	    os_ << '.' << std::flush;
	}
    }

    void Progress::fail()
    {
	fail_++;
	if(verbose_) {
	    os_ << "FAIL" << std::endl;
	}
	else {
	    os_ << 'F' << std::flush;
	}
    }

    void Progress::error()
    {
	error_++;
	if(verbose_) {
	    os_ << "ERROR" << std::endl;
	}
	else {
	    os_ << 'E' << std::flush;
	}
    }

    void Progress::done()
    {
	if(!verbose_) {
	    os_ << '\n';
	}
	os_ << "----------------------------------------------------------------------\n";
	if(fail_+error_ == 0) {
	    os_ << "OK (" << pass_ << " tests)\n";
	}
	else {
	    int total = pass_ + fail_ + error_;
	    os_ << "FAILED (" << total << " tests; "
		<< fail_ << " FAIL, "
		<< error_ <<" ERROR)\n";
	}
    }


    struct Entry {
	char * name;
	void (*f)();
    };


    class NonMatch {
    public:
	NonMatch(char ** begin, char ** end)
	    : begin_(begin),
	      end_(end)
	{}

	bool operator() (const Entry& e) const;

    private:
	char ** const begin_;
	char ** const end_;
    };

    bool NonMatch::operator() (const Entry& e) const
    {
	char ** i = begin_;
	while(i!=end_) {
	    if(std::strstr(e.name, *i)==e.name) return false;
	    ++i;
	}
	return true;
    }
}


int main(int argc, char ** argv)
{
    const char * const prog = argv[0];

    static const Entry entries[] = {
""")

    for name in testnames:
        w('\t{"%s", %s},\n' % (name, name))

    w(r"""    };

    static const size_t NENTRIES = sizeof(entries)/sizeof(entries[0]);

    bool verbose = false;
    bool just_list = false;

    int ch;
    while((ch = getopt(argc, argv, "+vl")) != -1) {
	switch(ch) {
	case 'v':
	    verbose = true;
	    break;
	case 'l':
	    just_list = true;
	    break;
	case '?':
	default:
	    std::cerr << "usage: " << prog << " [-v] [pattern ...]\n"
		      << "       " << prog << " -l [pattern ...]\n";
	    return 0;
	}
    }

    std::vector<Entry> chosen(entries, entries+NENTRIES);
    if(optind!=argc) {
	chosen.erase(std::remove_if(chosen.begin(), chosen.end(),
				    NonMatch(argv+optind, argv+argc)),
		     chosen.end());
    }

    if(just_list) {
	for(std::vector<Entry>::const_iterator i = chosen.begin();
	    i!=chosen.end();
	    ++i) {
	    std::cout << i->name << '\n';
	}
	return 0;
    }

    Progress p(std::cout, verbose);

    for(std::vector<Entry>::const_iterator i = chosen.begin();
	i!=chosen.end();
	++i) {

	const Entry& e = *i;

	p.begin(e.name);

	try {
	    e.f();
	    p.pass();
	}
	catch(testicle::AssertionError& err) {
	    p.fail();
	}
	catch(...) {
	    p.error();
	}
    }
    p.done();

    return p.rc();
}
""")


if __name__ == "__main__":
    import sys
    import getopt

    prog = os.path.split(sys.argv[0])[1]
    usage = ('usage: %(prog)s [-o outfile] [--tests=pattern] infile ...\n'
             '       %(prog)s --help\n'
             '       %(prog)s --version') % locals()
    outfile = 'test.cc'
    testres = []

    try:
        opts, infiles = getopt.getopt(sys.argv[1:], 'o:',
                                    ['tests=', 'version', 'help'])
        for opt, value in opts:
            if opt=='-o':
                outfile = value
            elif opt=='--tests':
                testres.append(re.compile(value))
            elif opt=='--version':
                print prog
                print "$Id$"
                print "Copyright (c) 2007 Jörgen Grahn."
                print "All rights reserved."
                sys.exit(0)
            elif opt=='--help':
                print usage
                sys.exit(0)
        if not infiles:
            raise ValueError('no input file specified')
    except (getopt.GetoptError, ValueError, re.error), s:
        print >>sys.stderr, s
        print >>sys.stderr, usage
        sys.exit(1)

    if not testres:
        testres.append(re.compile(r'^(.+::)?test'))

    tests = find_tests(infiles, testres)

    of = open(outfile, 'w')
    source(tests, of)
    of.close()

    sys.exit(0)
